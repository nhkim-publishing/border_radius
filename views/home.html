<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../assets/css/reset.css">
    <link rel="stylesheet" href="../assets/css/global.css">
    <!-- <link rel="stylesheet" href="../assets/css/header.css"> -->
    <link rel="stylesheet" href="../assets/css/home.css">
</head>

<body>        
    <article clgss="home-page">
        <div class="container">
            <section class="main-panel-wrap">
              <!-- s: 수정 -->
              <!-- <div class="overlaySvg"></div>
              <div class="svg-container" id="svgContainer"></div> -->
              <!-- e: 수정 -->

              <div class="main-panel">
                  <div class="main-panel-header">
                      <!-- 클라우드 pc 리스트 드롭다운 박스 -->
                      <div class="custom-select">
                          <div class="id-selector custom-select__trigger">
                              <button class="selector-btn"><span class="id">001E82265602COA</span>
                                  <img class="selectorBtnImg pc" src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/ic_id_selector.svg" alt="열기">
                                  <img class="selectorBtnImg mo" src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/chevron_Icon.svg" alt="열기">
                              </button>
                          </div>
                          <!-- 클라우드 pc 리스트 드롭다운 박스 : data-value -->
                          <ul class="id-selector-option custom-options">
                              <li class="custom-option" data-value="001E82265602COA"></li>
                              <li class="custom-option" data-value="001E82265602COB"></li>
                              <li class="custom-option" data-value="001E82265602COC"></li>
                              <li class="custom-option" data-value="001E82265602sss"></li>
                              <li class="custom-option" data-value="001E8226560fff"></li>
                              <li class="custom-option" data-value="001E82265602fff"></li>
                          </ul>
                      </div>
                      <button class="refresh-btn"><img src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/ic_refresh_24.svg" alt="icon"> <span>리프레시</span></button>
                  </div>                 

                  <!-- body -->
                  <div class="main-panel-body">
                      <!-- vod -->
                      <div class="cloud_vod">
                          <!-- 비디오 상태 변경 -->
                          <!-- mov_open -->
                          <!-- <video autoplay muted playsinline poster="../assets/images/vod/mov_open.svg">
                              <source src="../assets/images/vod/open.webm" type="video/webm">
                              <source src="../assets/images/vod/open.mp4" type="video/mp4">
                          </video> -->
                          <!-- mov_open -->
                          <!-- <video autoplay muted playsinline poster="../assets/images/vod/mov_open.svg">
                              <source src="../assets/images/vod/mov_close.webm" type="video/webm">
                              <source src="../assets/images/vod/mov_close.mp4" type="video/mp4">
                          </video> -->
                          <!-- mov_reboot -->
                          <!-- <video autoplay muted playsinline poster="../assets/images/vod/mov_open.svg">
                              <source src="../assets/images/vod/mov_reboot.webm" type="video/webm">
                              <source src="../assets/images/vod/mov_reboot.mp4" type="video/mp4">
                          </video> -->
                            <!-- mov_wait_open -->
                          <!-- <video autoplay muted playsinline poster="../assets/images/vod/mov_open.svg">
                              <source src="../assets/images/vod/mov_wait_open.webm" type="video/webm">
                              <source src="../assets/images/vod/mov_wait_open.mp4" type="video/mp4">
                          </video> -->
                            <!-- mov_wait_close -->
                          <video autoplay muted playsinline poster="../assets/images/vod/mov_wait_close.svg">
                              <source src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/vod/wait_close.webm" type="video/webm">
                              <source src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/vod/wait_close.mp4" type="video/mp4">
                          </video>                         
                      </div>
                      <!-- info -->
                      <div class="info-mo-layout">
                          <div class="cloud-pc-title-wrap">
                              <h2 class="cloud-pc-title">
                                  <!-- <span>Cloud PC</span><strong class="gradient-text gradient-text-blue">현재 접속
                                      중</strong>
                                  입니다. -->

                                  <!-- 접속 하는 중 (접속하기 버튼 선택 시) -->
                                  <!-- span>Cloud PC</span><strong class="gradient-text gradient-text-blue">접속 하는 중</strong> 입니다. -->

                                  <!-- 접속 가능 상태 -->
                                  <!-- span>Cloud PC</span><strong class="gradient-text gradient-text-blue">접속 가능 상태</strong> 입니다. -->

                                  <!-- 전원 부팅 중 -->
                                  <!-- span>Cloud PC</span><strong class="gradient-text gradient-text-blue">전원 부팅 중</strong> 입니다. -->

                                  <!-- 종료 -->
                                  <span>Cloud PC</span><strong class="gradient-text gradient-text-red">전원 종료 상태</strong> 입니다.

                                  <!-- 종료 중 -->
                                  <!-- <span>Cloud PC</span><strong class="gradient-text gradient-text-red">전원 종료 중</strong> 입니다. -->

                                  <!-- 접속 불가 -->
                                  <!-- <span>Cloud PC</span><strong class="gradient-text gradient-text-red">접속 불가 상태</strong> 입니다. -->
                              </h2>

                              <!-- 상태 설명 메세지 : 기획서 참고해서 넣어주세요. -->
                              <p class="connection-message">PC 전원을 켜고<br>가상 환경에 접속해주세요.</p>

                              <!-- 
                              progress bar : 접속하는 중에만 노출해주세요.
                              하단 스크립트 ' connectionTime ' 에 초단위로 값을 넣어주시면 됩니다.
                              -->
                              <!-- <div class="progress-container">
                                  <div class="progress-bar">
                                      <div class="progress-fill"></div>
                                  </div>
                              </div> -->

                          </div>

                          <!-- profile-info -->
                          <div class="profile-info">
                              <div class="info-row">
                                  <span class="info-label">Profile</span>
                                  <span class="info-value">직원 Standard</span>
                                  <span class="info-value">Windows 11 24H2, Office 365</span>
                              </div>
                              <div class="info-row">
                                  <span class="info-label">Cloud PC IP</span>
                                  <span class="info-value">10.214.124.79</span>
                              </div>
                              <div class="info-row">
                                  <span class="info-label">접속 위치</span>
                                  <span class="info-value">사내 접속</span>
                              </div>
                          </div>
                      </div>

                      <div class="buttons-container">
                          <button class="reboot-btn"><img src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/ic_reboot_28.svg" alt="icon">
                              <span>재부팅</span></button>
                          <!-- 접속하기 버튼 : 비활성화 일때 disabled 속성 추가 -->
                          <button class="connect-btn active">
                              <img class="connect-btn-img" src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/ic_play_28.svg" alt="icon">
                              <img class="connect-btn-disabled-img" src="https://kt-clould-portal-test-git-main-julias-projects-618eb078.vercel.app/assets/images/ic_play_28_disabled.svg"
                                  alt="icon">
                              <span>접속하기</span></button>
                      </div>
                  </div>
              </div>
            </section>


            <section class="sidebar">
               
            </section>
        </div>
    </article>


    <script>
        // 화면 크기에 따른 SVG 생성 함수
        function createResponsiveSvg() {
            const svgContainer = document.getElementById('svgContainer');
            const overlayElement = document.querySelector('.overlaySvg');

            const width = window.innerWidth;
            let svgContent = '';
            let overlaySvgContent = '';

            if (width >= 1480) {
                // 1480 이상의 화면
                svgContent = `<svg width="100%" height="767" viewBox="0 0 956 767" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 103.904C0 86.2313 14.3269 71.9044 32 71.9044H274.612C292.285 71.9044 306.612 57.5775 306.612 39.9044V32C306.612 14.3269 320.939 0 338.612 0L613.274 0L924 0C941.673 0 956 14.3269 956 32L956 630.725C956 648.398 941.673 662.725 924 662.725H632.066C614.393 662.725 600.066 677.051 600.066 694.724V735C600.066 752.673 585.739 767 568.066 767H32C14.3269 767 0 752.673 0 735V103.904Z" fill="#E1E7F4"/>
    </svg>`;

                overlaySvgContent = `<svg width="100%" height="767" viewBox="0 0 956 767" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M0 103.904C0 86.2313 14.3269 71.9044 32 71.9044H274.612C292.285 71.9044 306.612 57.5775 306.612 39.9044V32C306.612 14.3269 320.939 0 338.612 0L613.274 0L924 0C941.673 0 956 14.3269 956 32L956 630.725C956 648.398 941.673 662.725 924 662.725H632.066C614.393 662.725 600.066 677.051 600.066 694.724V735C600.066 752.673 585.739 767 568.066 767H32C14.3269 767 0 752.673 0 735V103.904Z" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>`;
            } else if (width >= 1080 && width <= 1479) {
                svgContent = `
<svg width="1000" height="667" viewBox="0 0 1000 667" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0 103.904C0 86.2313 14.3269 71.9044 32 71.9044H274.612C292.285 71.9044 306.612 57.5775 306.612 39.9044V32C306.612 14.3269 320.939 0 338.612 0L657.274 0L968 0C985.673 0 1000 14.3269 1000 32L1000 530.725C1000 548.398 985.673 562.725 968 562.725H676.066C658.393 562.725 644.066 577.051 644.066 594.724V635C644.066 652.673 629.739 667 612.066 667H32C14.3269 667 0 652.673 0 635V103.904Z" fill="#E1E7F4"/>
</svg>`;

                overlaySvgContent = `
<svg width="1000" height="667" viewBox="0 0 1000 667" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0 103.904C0 86.2313 14.3269 71.9044 32 71.9044H274.612C292.285 71.9044 306.612 57.5775 306.612 39.9044V32C306.612 14.3269 320.939 0 338.612 0L657.274 0L968 0C985.673 0 1000 14.3269 1000 32L1000 530.725C1000 548.398 985.673 562.725 968 562.725H676.066C658.393 562.725 644.066 577.051 644.066 594.724V635C644.066 652.673 629.739 667 612.066 667H32C14.3269 667 0 652.673 0 635V103.904Z" fill="rgba(0, 0, 0, 0.4)"/>
</svg>`;
            } else if (width >= 768 && width <= 1079) {
                const containerWidth = width - 64; // 패딩이나 여백을 제외한 컨테이너 너비
                const middleSvgWidth = containerWidth - (337 + 344); // 첫 번째와 마지막 SVG 너비를 뺀 중간 SVG 너비
                // 768 이상 1079 이하의 화면 
                svgContent = `<svg width="337" height="697" viewBox="0 0 336 697" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M337 697.04H32C14.3269 697.04 1.24319e-06 682.713 0 665.04V103.908C0.000196905 86.2353 14.327 71.9082 32 71.9082H274.612C292.285 71.9081 306.612 57.5812 306.612 39.9082V32C306.612 14.8675 320.076 0.87971 337 0.0400391V697.04Z" fill="#E1E7F4"/>
    </svg>
    <svg width="${middleSvgWidth}" height="697" preserveAspectRatio="none" viewBox="0 0 ${middleSvgWidth} 697" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect width="${middleSvgWidth}" height="697" fill="#E1E7F4"/>
    </svg>
    <svg width="344" height="697" viewBox="0 0 344 697" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M312 0C329.673 8.92959e-05 344 14.3269 344 32V560.725C344 578.398 329.673 592.725 312 592.725H60.0664C42.3933 592.725 28.0664 607.052 28.0664 624.725L28.0654 665C28.0654 681.341 15.8168 694.816 0 696.755V0H312Z" fill="#E1E7F4"/>
    </svg>`;

                overlaySvgContent = `<svg width="337" height="697" viewBox="0 0 336 697" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M337 697.04H32C14.3269 697.04 1.24319e-06 682.713 0 665.04V103.908C0.000196905 86.2353 14.327 71.9082 32 71.9082H274.612C292.285 71.9081 306.612 57.5812 306.612 39.9082V32C306.612 14.8675 320.076 0.87971 337 0.0400391V697.04Z" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>
    <svg width="${middleSvgWidth}" height="697" preserveAspectRatio="none" viewBox="0 0 ${middleSvgWidth} 697" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect width="${middleSvgWidth}" height="697" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>
    <svg width="344" height="697" viewBox="0 0 344 697" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M312 0C329.673 8.92959e-05 344 14.3269 344 32V560.725C344 578.398 329.673 592.725 312 592.725H60.0664C42.3933 592.725 28.0664 607.052 28.0664 624.725L28.0654 665C28.0654 681.341 15.8168 694.816 0 696.755V0H312Z" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>`;

            } else {
                // 767 이하의 화면 - 가로축 10~50% 동적 조절
                const containerWidth = width - 40; // 패딩이나 여백을 제외한 컨테이너 너비
                const middleSvgWidth = containerWidth - (62 + 116); // 첫 번째와 마지막 SVG 너비를 뺀 중간 SVG 너비
                svgContent = `<svg width="62" height="578" viewBox="0 0 62 578" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M62 578H24C10.7452 578 7.08983e-07 567.255 0 554V24.9043C3.9731e-05 11.6495 10.7452 0.904297 24 0.904297H62V578Z" fill="#E1E7F4"/>
    </svg>
    <svg width="${middleSvgWidth}" height="577" preserveAspectRatio="none" viewBox="0 0 ${middleSvgWidth} 577" fill="none" xmlns="http://www.w3.org/2000/svg">
    <rect width="${middleSvgWidth}" height="577" fill="#E1E7F4"/>
    </svg>
    <svg width="116" height="637" viewBox="0 0 116 637" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M92 0C105.255 6.37229e-05 116 10.7452 116 24V613C116 626.255 105.255 637 92 637H0V59.9043H11.9863C25.2411 59.9042 35.9863 49.1591 35.9863 35.9043V24C35.9863 10.7452 46.7315 0 59.9863 0H92Z" fill="#E1E7F4"/>
    </svg>`;

                overlaySvgContent = `<svg width="62" height="578" viewBox="0 0 62 578" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M62 578H24C10.7452 578 7.08983e-07 567.255 0 554V24.9043C3.9731e-05 11.6495 10.7452 0.904297 24 0.904297H62V578Z" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>
    <svg width="${middleSvgWidth}" height="577" preserveAspectRatio="none" viewBox="0 0 ${middleSvgWidth} 577" fill="none" xmlns="http://www.w3.org/2000/svg">
    <rect width="${middleSvgWidth}" height="577" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>
    <svg width="116" height="637" viewBox="0 0 116 637" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M92 0C105.255 6.37229e-05 116 10.7452 116 24V613C116 626.255 105.255 637 92 637H0V59.9043H11.9863C25.2411 59.9042 35.9863 49.1591 35.9863 35.9043V24C35.9863 10.7452 46.7315 0 59.9863 0H92Z" fill="rgba(0, 0, 0, 0.4)"/>
    </svg>`;
            }

            // SVG 컨테이너에 SVG 내용 설정
            svgContainer.innerHTML = svgContent;

            // 오버레이 요소에 SVG 내용 설정 (RGBA 채우기)
            if (overlayElement) {
                overlayElement.innerHTML = overlaySvgContent;

                // 오버레이 스타일 설정
                overlayElement.style.position = 'absolute';
                overlayElement.style.top = '0';
                overlayElement.style.left = '0';
                overlayElement.style.width = '100%';
                overlayElement.style.display = 'none';
                overlayElement.style.alignItems = 'flex-end';
                overlayElement.style.pointerEvents = 'none';
                overlayElement.style.zIndex = '9';

                // backgroundColor 제거 (fill 속성으로 대체)
                overlayElement.style.backgroundColor = '';
            }
        }

        // DOM이 로드되면 SVG 생성
        document.addEventListener('DOMContentLoaded', function () {
            createResponsiveSvg();
            setupOverlayControls();
        });

        // 화면 크기가 변경될 때 SVG 업데이트
        window.addEventListener('resize', createResponsiveSvg);

        // 오버레이 컨트롤 설정
        function setupOverlayControls() {
            const refreshBtn = document.querySelector('.refresh-btn');
            const overlayElement = document.querySelector('.overlaySvg');

            if (refreshBtn && overlayElement) {
                refreshBtn.addEventListener('click', function () {
                    overlayElement.style.display = 'flex';
                    showLoadingSpinner();
                    // 3초 후에 오버레이 숨기기 (로딩 시뮬레이션)
                    // setTimeout(function() {
                    //     overlayElement.style.display = 'none';
                    // }, 3000);
                });
            }
        }

        // 로딩 스피너 생성 및 표시 함수
        function showLoadingSpinner() {
            // 기존 스피너가 있으면 제거
            hideLoadingSpinner();

            // 로딩 스피너 컨테이너 생성
            const spinnerContainer = document.createElement('div');
            spinnerContainer.className = 'loading-spinner-container';

            // 컨테이너 스타일 설정
            spinnerContainer.style.position = 'absolute';
            spinnerContainer.style.top = '50%';
            spinnerContainer.style.left = '50%';
            spinnerContainer.style.transform = 'translate(-50%, -50%)';
            spinnerContainer.style.display = 'flex';
            spinnerContainer.style.flexDirection = 'column';
            spinnerContainer.style.alignItems = 'center';
            spinnerContainer.style.justifyContent = 'center';
            spinnerContainer.style.zIndex = '99';

            // 스피너 요소 생성
            const spinner = document.createElement('div');
            spinner.className = 'loading-spinner';

            // 스피너 스타일 설정
            spinner.style.width = '32px';
            spinner.style.height = '32px';
            spinner.style.border = '3px solid rgba(255, 255, 255, 0.28)';
            spinner.style.borderTop = '3px solid #2DBDB6';
            spinner.style.borderRadius = '50%';
            spinner.style.marginBottom = '16px';

            // 애니메이션 적용
            spinner.style.animation = 'spin 1s linear infinite';

            // 텍스트 요소 생성
            const spinnerText = document.createElement('div');
            spinnerText.className = 'loading-spinner-text';
            spinnerText.textContent = '리프레시 중입니다.';

            // 텍스트 스타일 설정
            spinnerText.style.color = '#fff';
            spinnerText.style.fontSize = '14px';
            spinnerText.style.fontWeight = '300';
            spinnerText.style.textAlign = 'center';

            // 스타일시트에 애니메이션 키프레임 추가
            if (!document.getElementById('spinner-style')) {
                const styleSheet = document.createElement('style');
                styleSheet.id = 'spinner-style';
                styleSheet.textContent = `
            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        `;
                document.head.appendChild(styleSheet);
            }

            // 요소들을 컨테이너에 추가
            spinnerContainer.appendChild(spinner);
            spinnerContainer.appendChild(spinnerText);

            // 오버레이 요소에 스피너 컨테이너 추가
            const overlayElement = document.querySelector('.overlaySvg');
            if (overlayElement) {
                overlayElement.appendChild(spinnerContainer);
            } else {
                // 오버레이가 없으면 body에 직접 추가
                document.body.appendChild(spinnerContainer);
            }
        }

        // 로딩 스피너 숨기기 함수
        function hideLoadingSpinner() {
            const spinnerContainer = document.querySelector('.loading-spinner-container');
            if (spinnerContainer) {
                spinnerContainer.remove();
            }
        }

        //브라우저 별 다른 비디오 확장자로 보여지도록
        function setOptimalVideoSourcesForAllVideos() {
        // 페이지 내 모든 비디오 요소 선택
        const videoElements = document.querySelectorAll('video');
        
        if (videoElements.length === 0) return;
        
        // 브라우저 및 기기 감지
        const userAgent = navigator.userAgent;
        const isSafari = /^((?!chrome|android).)*safari/i.test(userAgent);
        
        // 기존 iOS 감지
        const isOldiOS = /iPhone|iPad|iPod/i.test(userAgent);
        
        // 터치 기능 감지 (최신 iPadOS 감지 위한 추가 체크)
        const hasTouchScreen = ('ontouchstart' in window) || 
                            (navigator.maxTouchPoints > 0) || 
                            (navigator.msMaxTouchPoints > 0);
        
        // 최신 iPadOS 감지 (Safari + Mac + 터치스크린)
        const isNewIPad = isSafari && 
                        /Mac/.test(userAgent) && 
                        hasTouchScreen;
        
        // iOS 기기인 경우 (기존 iOS 기기 또는 최신 iPadOS)
        const isIOS = isOldiOS || isNewIPad;
        
        // Safari 브라우저 또는 iOS 기기인 경우 MP4 사용
        const needsMP4 = isSafari || isIOS;
        
        console.log('브라우저 정보:', {
            userAgent,
            isSafari,
            isIOS,
            needsMP4
        });
        
        // 각 비디오 요소에 대해 처리
        videoElements.forEach(videoElement => {
            // 비디오의 src 경로 확인 또는 poster 경로에서 추정
            let basePath;
            const sourceSrc = videoElement.querySelector('source')?.src;
            const posterSrc = videoElement.getAttribute('poster');
            
            if (sourceSrc) {
                // src가 있으면 확장자를 제외한 기본 경로 추출
                basePath = sourceSrc.substring(0, sourceSrc.lastIndexOf('.'));
            } else if (posterSrc) {
                // poster 경로에서 파일명 추정 (e.g., mov_open.svg -> open)
                const fileName = posterSrc.split('/').pop().replace('mov_', '').replace('.svg', '');
                basePath = `../assets/images/vod/${fileName}`;
            } else {
                // 경로를 추정할 수 없는 경우
                console.error('비디오 소스 경로를 추정할 수 없습니다.');
                return;
            }
            
            if (needsMP4) {
                // Safari 또는 iOS 기기는 MP4 사용
                videoElement.innerHTML = `<source src="${basePath}.mp4" type="video/mp4">`;
            } else {
                // 다른 브라우저는 WebM 사용
                videoElement.innerHTML = `<source src="${basePath}.webm" type="video/webm">`;
            }
            
            // 비디오 로드
            videoElement.load();
            
            // 오류 발생 시 MP4로 폴백
            videoElement.addEventListener('error', function() {
                console.error('비디오 로드 오류. MP4로 대체합니다.');
                videoElement.innerHTML = `<source src="${basePath}.mp4" type="video/mp4">`;
                videoElement.load();
            });
        });
    }

    document.addEventListener('DOMContentLoaded', setOptimalVideoSourcesForAllVideos);
    </script>

    <script>
        // 홈화면 : Cloud PC 종료시
        //openAlert('alertPcEnd');
        // 홈화면 : Cloud PC 전환 시
        //openAlert('alertPcConversion');
        // 홈화면 : Cloud PC 재부팅 실패시
        //openAlert('alertPcBootFail');

        /////////  커스텀 셀렉 박스  
        window.addEventListener('DOMContentLoaded', function () {

            // 셀렉 박스 호버 이벤트
            const selectorTrigger = document.querySelector('.selector-btn');
            selectorTrigger.addEventListener('mouseenter', () => {
                selectorTrigger.classList.add('hover');
            });
            selectorTrigger.addEventListener('mouseleave', () => {
                selectorTrigger.classList.remove('hover');
            });

            // 셀렉트 요소 가져오기
            const selectElement = document.querySelector('.custom-select');
            const options = selectElement.querySelectorAll('.custom-option');

            // 옵션이 1개 이하인 경우 버튼 이미지 변경
            if (options.length <= 1) {
                const trigger = selectElement.querySelector('.custom-select__trigger');
                const selectorBtn = trigger.querySelector('.selector-btn');
                changeButtonImage(trigger);
                selectorTrigger.addEventListener('mouseenter', () => {
                    selectorTrigger.classList.remove('hover');
                });
            }

            // 첫번째 li의 data-value를 span.id에 설정
            // const firstOption = document.querySelector('.custom-option');
            // if (firstOption) {
            //     const firstDataValue = firstOption.getAttribute('data-value');
            //     const idSpan = document.querySelector('.selector-btn .id');

            //     if (firstDataValue && idSpan) {
            //         idSpan.textContent = firstDataValue;

            //         // 첫 번째 옵션에 selected 클래스 추가
            //         firstOption.classList.add('selected');
            //     }
            // }
        });

        // 셀렉트 트리거 클릭 이벤트
        document.querySelector('.custom-select__trigger').addEventListener('click', function () {
            // 옵션 개수 확인
            const options = this.parentElement.querySelectorAll('.custom-option');

            // 옵션이 1개 이하인 경우 드롭다운을 열지 않음
            if (options.length <= 1) {
                // 드롭다운을 열지 않음 (아무 동작 없음)
                return;
            } else {
                // 옵션이 2개 이상이면 드롭다운 열기
                this.parentElement.classList.toggle('open');
            }
        });
        // 버튼 이미지 변경 함수
        function changeButtonImage(trigger) {
            const buttonImage = trigger.querySelector('.selectorBtnImg');

            if (buttonImage) {
                buttonImage.src = '../assets/images/ic_id_selector_1.svg'; // 원하는 이미지로 변경
            }
        }
        document.addEventListener('click', function (e) {
            const select = document.querySelector('.custom-select');
            if (!select.contains(e.target)) {
                select.classList.remove('open');
            }
        });
        document.querySelectorAll('.custom-option').forEach(option => {
            option.addEventListener('click', function () {
                // 이전에 선택된 옵션 확인 후 selected 클래스 제거
                const selectedOption = this.parentNode.querySelector('.custom-option.selected');
                if (selectedOption) {
                    selectedOption.classList.remove('selected');
                }
                // 현재 옵션에 selected 클래스 추가
                this.classList.add('selected');
                // 선택된 텍스트로 트리거 업데이트
                const trigger = this.closest('.custom-select').querySelector('.custom-select__trigger span');
                trigger.textContent = this.textContent;
                // 선택 후 드롭다운 닫기
                this.closest('.custom-select').classList.remove('open');
            });
        });

        // 각 옵션의 textContent를 해당 요소의 data-value 값으로 설정
        const options = document.querySelectorAll('.custom-option');
        options.forEach(option => {
            const dataValue = option.getAttribute('data-value');
            if (dataValue) {
                option.textContent = dataValue;
            }
        });

        ///////progress-bar
        // 여기에서 접속 시간을 초 단위로 설정합니다
       
        const connectionTime = 5; // 5초 (이 값을 변경하면 됩니다)

        const progressBar = document.querySelector('.progress-fill');
        let progress = 0;

        function updateProgressBar(value) {
            progressBar.style.width = `${value}%`;
        }
        // 페이지 로드 시 자동으로 프로그레스 바 시작
        document.addEventListener('DOMContentLoaded', () => {
            if(progressBar) {
                // 업데이트 간격 계산 (ms)
                const updateInterval = connectionTime * 10; // 100번 업데이트하여 부드럽게 표시
                const interval = setInterval(() => {
                    progress += 1;
                    updateProgressBar(progress);
                    if (progress >= 100) {
                        clearInterval(interval);
                    }
                }, updateInterval); 
            }
        });
    

        //////////하단 재부팅, 접속하기 버튼 호버 이벤트
        const rebootBtn = document.querySelector('.reboot-btn');
        const connectBtn = document.querySelector('.connect-btn');
        // 접속하기가 활성화 일 경우에만 동작
        if (!connectBtn.disabled) {

            rebootBtn.addEventListener('mouseenter', () => {
                rebootBtn.classList.add('active');
                connectBtn.classList.remove('active');
            });
            connectBtn.addEventListener('mouseenter', () => {
                rebootBtn.classList.remove('active');
                connectBtn.classList.add('active');
            });

        } else {
            rebootBtn.classList.add('active');
            connectBtn.classList.remove('active');
        }

        ///////// 공지사항 툴팁
        function setupNoticeTooltips() {
        
        const noticeLinks = document.querySelectorAll('.notice-item a');
        noticeLinks.forEach(link => {
            // 내용이 넘쳐서 말줄임표가 표시되고 있는지 확인
            if (link.scrollWidth > link.clientWidth) {
                // 링크의 부모 요소 가져오기
                const parentElement = link.parentElement;

                // 부모 요소의 position 확인 (툴팁 위치 지정을 위해)
                if (window.getComputedStyle(parentElement).position === 'static') {
                    parentElement.style.position = 'relative';
                }
                // 툴팁 요소 생성
                const tooltip = document.createElement('div');
                tooltip.className = 'hover-text';
                tooltip.textContent = link.textContent;

                // 툴팁을 부모 요소에 추가
                parentElement.appendChild(tooltip);

                // 마우스 이벤트 리스너 (링크에 추가)
                link.addEventListener('mouseenter', () => {
                    tooltip.style.visibility = 'visible';
                    tooltip.style.opacity = '1';
                });

                link.addEventListener('mouseleave', () => {
                    tooltip.style.visibility = 'hidden';
                    tooltip.style.opacity = '0';
                });
            }
        });
    }

    if (window.innerWidth >= 1080) {
    // 페이지 로드 시 실행
    document.addEventListener('DOMContentLoaded', setupNoticeTooltips);
    }
    // 화면 크기 변경 시 실행
    window.addEventListener('resize', setupNoticeTooltips);

        // 초기 설치 프로그램 다운로드
const actionButtons = document.querySelectorAll('.action_button');
// 화면 너비 감지
const windowWidth = window.innerWidth;

// 디바이스 타입 감지 함수 (PC vs 모바일/태블릿)
function detectDeviceType() {
    const userAgent = navigator.userAgent.toLowerCase();
    // 터치 기능 감지
    const hasTouchScreen = ('ontouchstart' in window) || 
                          (navigator.maxTouchPoints > 0) || 
                          (navigator.msMaxTouchPoints > 0);
    
    // 아이패드 감지를 위한 추가 체크
    const isIPad = /ipad/.test(userAgent) || 
                   (userAgent.includes('mac') && hasTouchScreen) ||
                   (userAgent.includes('macintosh') && hasTouchScreen);
    
    if (isIPad || /android|webos|iphone|ipod|blackberry|iemobile|opera mini/i.test(userAgent)) {
        return 'Mobile';
    } else {
        return 'Desktop';
    }
}

// PC OS 감지 함수
function detectOS() {
    const userAgent = navigator.userAgent.toLowerCase();
    const platform = navigator.platform.toLowerCase();
    const deviceType = detectDeviceType();
    
    // 모바일/태블릿으로 감지되면 모바일 OS 반환
    if (deviceType === 'Mobile') {
        return detectMobileOS();
    }
    
    // PC OS 감지
    if (userAgent.indexOf('win') !== -1 || platform.indexOf('win') !== -1) {
        return 'Windows';
    } else if (userAgent.indexOf('mac') !== -1 || platform.indexOf('mac') !== -1) {
        return 'MacOS';
    } else {
        return 'Other OS';
    }
}

// 모바일 OS 감지 함수
function detectMobileOS() {
    const userAgent = navigator.userAgent.toLowerCase();
    const hasTouchScreen = ('ontouchstart' in window) || 
                          (navigator.maxTouchPoints > 0) || 
                          (navigator.msMaxTouchPoints > 0);
    
    // 아이패드 감지를 위한 추가 체크
    const isIPad = /ipad/.test(userAgent) || 
                   (userAgent.includes('mac') && hasTouchScreen) ||
                   (userAgent.includes('macintosh') && hasTouchScreen);
    
    if (userAgent.indexOf('android') !== -1) {
        return 'Android';
    } else if (
        userAgent.indexOf('iphone') !== -1 ||
        isIPad ||
        userAgent.indexOf('ipod') !== -1
    ) {
        return 'iOS';
    } else {
        return 'Other';
    }
}

// 디바이스 타입과 OS 감지
const deviceType = detectDeviceType();
const currentOS = detectOS();

// 적절한 버튼 활성화
function activateButton(buttonClass) {
    const button = document.querySelector(`.action_button.${buttonClass}`);
    if (button && button.nextElementSibling) {
        button.nextElementSibling.classList.add('show');
        const icon = button.querySelector('.btn-control-icon');
        if (icon) {
            icon.classList.add('active');
        }
    }
}

// 디바이스와 OS에 따른 버튼 활성화 로직
if (deviceType === 'Mobile' || windowWidth <= 1079) {
    // 모바일/태블릿 디바이스 또는 작은 화면
    activateButton('tablet');
    console.log('태블릿/모바일 버튼 활성화');
    
    // 필요한 경우 iOS/Android 구분하여 추가 처리
    // const mobileOS = detectMobileOS();
    // if (mobileOS === 'Android') { ... }
    // else if (mobileOS === 'iOS') { ... }
} else {
    // PC 디바이스
    if (currentOS === 'Windows') {
        activateButton('windows');
        console.log('윈도우 버튼 활성화');
    } else if (currentOS === 'MacOS') {
        activateButton('mac');
        console.log('맥OS 버튼 활성화');
    } else {
        // 기본값은 윈도우
        activateButton('windows');
        console.log('기타 OS - 윈도우 버튼 활성화');
    }
}

        // Add click event listener to each action button
        actionButtons.forEach(button => {
            button.addEventListener('click', function () {
                // Get the control icon inside this button
                const controlicon = this.querySelector('.btn-control-icon');

                // Get the content div that follows this button
                const content = this.nextElementSibling;

                // Check if this content is already visible
                const isVisible = content.classList.contains('show');

                // Close all open contents and remove active class from all control icons
                document.querySelectorAll('.show_content').forEach(item => {
                    if (item !== content) {
                        item.classList.remove('show');
                    }
                });

                document.querySelectorAll('.btn-control-icon').forEach(icon => {
                    if (icon !== controlicon) {
                        icon.classList.remove('active');
                    }
                });
                // Toggle this content and control icon
                if (isVisible) {
                    // If it's already visible, hide it and remove active class
                    content.classList.remove('show');
                    controlicon.classList.remove('active');
                } else {
                    // If it's hidden, show it and add active class
                    content.classList.add('show');
                    controlicon.classList.add('active');

                }
            });
        });

        document.addEventListener('DOMContentLoaded', function() {
        const videos = document.querySelectorAll('.cloud_vod video');
        videos.forEach(video => {
            // 비디오가 로드되기 전에 숨김
            video.style.opacity = '0';
            
            // 비디오 메타데이터 로드 완료 후 표시
            video.addEventListener('loadedmetadata', function() {
                video.style.opacity = '1';
            });
            
            // 이미 메타데이터가 로드된 경우에 대한 처리
            if (video.readyState >= 1) {
                video.style.opacity = '1';
            }
        });
    });

    </script>
</body>

</html>